# Evision Benchmark - Densenet121

```elixir
Mix.install(
  [
    {:evision, "~> 0.1.0-dev", github: "cocoa-xu/evision"}
  ],
  system_env: [
    {"EVISION_PREFER_PRECOMPILED", "true"}
  ]
)
```

## Section

```elixir
alias Evision, as: Cv
```

```elixir
:inets.start()
:ssl.start()

defmodule Helper do
  def download!(url, save_as, overwrite \\ false)

  def download!(url, save_as, false) do
    unless File.exists?(save_as) do
      download!(url, save_as, true)
    end

    :ok
  end

  def download!(url, save_as, true) do
    http_opts = []
    opts = [body_format: :binary]
    arg = {url, []}

    body =
      case :httpc.request(:get, arg, http_opts, opts) do
        {:ok, {{_, 200, _}, _, body}} ->
          body

        {:error, reason} ->
          raise inspect(reason)
      end

    File.write!(save_as, body)
  end
end
```

```elixir
defmodule DetectionModel do
  def postprocess(mat, detections, net, confidence_threshold) do
    {:ok, out_layers} = Cv.DNN.Net.getUnconnectedOutLayers(net)
    {:ok, out_layer} = Cv.DNN.Net.getLayer(net, Enum.at(out_layers, 0))
    out_layer_type = Cv.DNN.Layer.get_type(out_layer) |> IO.iodata_to_binary()
    _postprocess(mat, detections, net, confidence_threshold, out_layer_type, [])
  end

  defp _postprocess(_mat, [], _net, _confidence_threshold, <<"DetectionOutput">>, acc),
    do: {:ok, Enum.reverse(acc)}

  defp _postprocess(
         mat,
         [outs | detections],
         net,
         confidence_threshold,
         <<"DetectionOutput">>,
         acc
       ) do
    {:ok, data} = Cv.Mat.to_binary(outs)
    {:ok, {h, w, _}} = Cv.Mat.shape(mat)
    {:ok, translated_outs} = _translate_outs(confidence_threshold, data, h, w, [])

    _postprocess(mat, detections, net, confidence_threshold, "DetectionOutput", [
      translated_outs | acc
    ])
  end

  defp _translate_outs(_confidence_threshold, <<>>, _h, _w, acc), do: {:ok, acc}

  defp _translate_outs(
         confidence_threshold,
         <<_batch_id::float-size(32)-little, class_id::float-size(32)-little,
           confidence::float-size(32)-little, left::float-size(32)-little,
           top::float-size(32)-little, right::float-size(32)-little,
           bottom::float-size(32)-little, rest::binary>>,
         h,
         w,
         acc
       ) do
    if confidence > confidence_threshold do
      [class_id, l, t, r, b] =
        Enum.map([class_id, left, top, right, bottom], fn f -> trunc(f) end)

      width = r - l + 1
      height = b - t + 1

      [l, t, r, b] =
        if width <= 2 or height <= 2 do
          Enum.map([left * w, top * h, right * w, bottom * h], fn f -> trunc(f) end)
        else
          [l, t, r, b]
        end

      _translate_outs(confidence_threshold, rest, h, w, [
        {class_id - 1, confidence, l, t, r, b} | acc
      ])
    else
      _translate_outs(confidence_threshold, rest, h, w, acc)
    end
  end

  def get_labels(class_label_file) do
    class_label_file
    |> File.read!()
    |> String.split("\n")
  end

  def predict(mat, model, out_names, opts \\ []) do
    {:ok, blob} = Cv.DNN.blobFromImage(mat, opts)

    {:ok, model} = Cv.DNN.Net.setInput(model, blob, name: "", scalefactor: 1.0, mean: [0, 0, 0])

    start_time = :os.system_time(:millisecond)
    {:ok, detections} = Cv.DNN.Net.forward(model, outBlobNames: out_names)
    end_time = :os.system_time(:millisecond)
    inference_time = end_time - start_time
    IO.puts("Inference time=>#{inference_time} ms")
    {:ok, mat, detections, inference_time}
  end

  def predict_file(image_file, model, out_names, opts \\ []) do
    {:ok, mat} = Cv.imread(image_file)
    predict(mat, model, out_names, opts)
  end

  def get_model(filename) do
    net = Cv.DNN.readNetFromONNX!(filename)
    out_names = Cv.DNN.Net.getUnconnectedOutLayersNames!(net)
    {:ok, net, out_names}
  end
end
```

```elixir
defmodule DenseNet121 do
  defp download_model(opset_version \\ 12) when opset_version in [3, 6, 7, 8, 9, 12] do
    onnx_filename = "densenet-#{opset_version}.onnx"
    test_filename = "CyprusShorthair.jpg"

    Helper.download!(
      "https://github.com/onnx/models/blob/main/vision/classification/densenet-121/model/densenet-#{opset_version}.onnx",
      onnx_filename
    )

    Helper.download!(
      "https://upload.wikimedia.org/wikipedia/commons/b/b9/CyprusShorthair.jpg",
      "CyprusShorthair.jpg"
    )

    {onnx_filename, test_filename}
  end

  def get_detection_model(opset_version \\ 12) do
    {onnx_filename, test_filename} = download_model(opset_version)
    {:ok, net, out_names} = DetectionModel.get_model(onnx_filename)
    test_mat = Cv.imread!(test_filename)
    {net, out_names, test_mat}
  end

  def benchmark(times, opset_version \\ 12) do
    {net, out_names, test_mat} = get_detection_model(opset_version)

    inference_times =
      for _ <- 1..times, reduce: [] do
        inference_times ->
          {:ok, _mat, _detections, inference_time} =
            DetectionModel.predict(test_mat, net, out_names,
              scalefactor: 1,
              swapRB: true,
              mean: [128, 128, 128],
              size: [224, 224]
            )

          [inference_time | inference_times]
      end

    inference_times
  end
end
```

```elixir
inference_times = DenseNet121.benchmark(50)
Enum.sum(inference_times) / Enum.count(inference_times)
```
